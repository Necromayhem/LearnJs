// roadmap

// 1. Что такое колбек?

// Колбэк(callback) - это функция, переданная в другую функцию в качестве аргумента и вызванная внутри этой функции по мере необходимости. Колбэки обычно используются для обработки асинхронных операций, таких как запросы к серверу, считывание файлов или таймеры.

// function fetchData(callback){
//     setTimeout(() => {
//         const data = "Данные получены"
//         callback(data)
//     }, 1000)
// }

// fetchData((result) => {
//     console.log(result);
// }) // Данные получены


// 2. Что такое промисы? Чем они отличаются от колбеков?

// Промис - это объект, представляющий собой конечный результат асинхронной операции. Промис может находиться в трёх состояниях: 
// Ожидание (Pending): начальное состояние, ни выполнен, ни отклонен.
// Выполнен (Fulfilled): операция завершилась успешно, и промис получает результат.
// Отклонен (Rejected): операция завершилась неуспешно, и промис получает причину отказа.

// Промисы позволяют более структурированным образом обрабатывать результаты асинхронных операций, избегая "адского колбека", который может возникнуть при использовании вложенных колбеков. С помощью промисов вы можете организовать код так, чтобы он был более читаемым и управляемым.

// Чем отличаются промисы от колбеков?

// Структура:

// Колбеки: это функции, переданные в другие функции и вызываемые по мере необходимости. Код может быстро превратиться в "адский колбек", если много уровней вложенности.

// Промисы: представляют собой объекты с методами для обработки успешного или неуспешного завершения операции (then, catch, finally).

// Управление состоянием:

// Колбеки: сложно управлять состоянием, так как функции вызываются сразу по завершении асинхронной операции.

// Промисы: предоставляют явное состояние (ожидание, выполнен, отклонен), что делает код более предсказуемым и понятным.

// Ошибки:

// Колбеки: для обработки ошибок вам необходимо явно вызывать функцию-обработчик ошибок в случае отсутствия.

// Промисы: любые ошибки, возникшие в промисе (включая исключения), можно обрабатывать через catch.

// Цепочки:

// Колбеки: сложно создавать цепочки обработки, так как каждая операция требует передачу следующей функции.

// Промисы: позволяют использовать методы then для создания последовательных цепочек, которые делают код более линейным и читаемым.



// 3. Зачем нужны промисы?

// В целом, промисы делают процесс работы с асинхронными операциями более управляемым и надежным, что минимизирует количество ошибок и улучшает читаемость кода. С появлением синтаксиса async/await работа с промисами стала ещё более удобной.


// 4. Являются ли аргументы then колбеками?

// Да, аргументы метода .then() в промисах являются колбеками. Когда вы передаете функцию в .then(), эта функция будет вызвана, когда промис будет выполнен успешно (разрешен). То же самое относится и к методу .catch(), который принимает функцию для обработки ошибок, когда промис отклонен.


// 5. Является ли промис синтаксическим сахаром и над чем?

// Промисы можно рассматривать как синтаксический сахар над механикой работы с колбеками для асинхронных операций в JavaScript. Основная идея промисов заключается в том, что они позволяют улучшить читаемость и структуру кода, который обращается с асинхронными операциями, избегая "адского колбека", который возникает при глубоком вложении функций.


// 6. Метод then() возвращает новый промис?

// Да, метод .then() возвращает новый промис. Это одно из ключевых свойств промисов, которое позволяет создавать цепочки промисов и упрощает асинхронное программирование.


// 7. Что будет, если на завершенный промис добавить .then()?

// Если вы добавите метод .then() к уже завершённому промису, он всё равно выполнится. Поведение будет зависеть от состояния, в котором находится промис:

// Если промис выполнен (resolved): Метод .then() вызовет функцию колбека, переданную в него, с результатом разрешения промиса. 
// Если промис отклонен (rejected): Метод .then() вызовет функцию для обработки ошибок (если она предоставлена вторым аргументом или если используется метод .catch()).





// После catch: then выполнится только если catch вернёт значение (или промис), даже если первоначальный промис был отклонен.

// Перед catch:

// Если промис реджектится, then не выполнится, если не предусмотрена обработка ошибок.

// Если промис резолвится, then выполнится без проблем, а catch не будет вызван.



















