// Date

let now = new Date();
console.log(now);


// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
console.log(Jan01_1970); // Thu Jan 01 1970 03:00:00 GMT+0300 (Москва, стандартное время)

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24*3600*1000);
console.log(Jan02_1970); // Fri Jan 02 1970 03:00:00 GMT+0300 (Москва, стандартное время)

// 31 декабря 1969 года
let Dec31_1969 = new Date(-24*3600*1000)
console.log(Dec31_1969); // Wed Dec 31 1969 03:00:00 GMT+0300 (Москва, стандартное время)


// new Date(datestring)

let date = new Date("2017-01-26")
console.log(date); // Thu Jan 26 2017 03:00:00 GMT+0300 (Москва, стандартное время)
// Время не указано, поэтому оно становится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)


//new Date(year, month, date, hours, minutes, seconds, ms)

new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0


let date2 = new Date(2011, 0, 1, 2, 3, 4, 567);
console.log(date2); // 1.01.2011, 02:03:04.567


// Получение компонентов даты

// getFullYear() // получить год(4 цифры)
// getMonth() // получить месяц(от 0 до 11)
// getDate() // получить день месяца от 1 до 31, что несколько противоречит
// названию месяца

// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// // Получить, соответственно, часы, минуты, секунды или миллисекунды.

// getDay() // Вернуть день недели от 0 (воскресенье) до 6 (суббота). Несмотря на то, что в ряде стран за первый день недели принят понедельник, в JavaScript начало недели приходится на воскресенье.

// Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.

// Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".

let date3 = new Date();
console.log(date3.getHours()); // 13
console.log(date3.getUTCHours()); // 10


// getTime()
// Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

console.log(date3.getTime()); // 1723632705669

// getTimezoneOffset()
// Возвращает разницу в минутах между UTC и местным часовым поясом:

console.log(date3.getTimezoneOffset()); // -180 (нахожусь в UTC+3)

// Установка компонентов даты

// setFullYear(year, [month], [date])
// setMonth(month, [date])
// setDate(date)
// setHours(hour, [min], [sec], [ms])
// setMinutes(min, [sec], [ms])
// setSeconds(sec, [ms])
// setMilliseconds(ms)
// setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)

// У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

// Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: setHours. Если какая-то компонента не указана, она не меняется.


let today = new Date();

today.setHours(0);
console.log(today);

today.setHours(0, 0, 0, 0)
console.log(today);


// Автоисправление даты

// Автоисправление – это очень полезная особенность объектов Date. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

let date4 = new Date(2013, 0, 32)// 32 Jan 2013 ?
console.log(date4); // Fri Feb 01 2013

let date5 = new Date(2016, 1, 28);
date5.setDate(date5.getDate() + 2);
console.log(date5); // Tue Mar 01 2016

// Эту возможность часто используют, чтобы получить дату по прошествии заданного отрезка времени. Например, получим дату «спустя 70 дней с текущего момента»:

let date6 = new Date();
date6.setDate(date6.getDate() + 70);
console.log(date6); // Wed Oct 23 2024

// Также можно установить нулевые или даже отрицательные значения. Например:

let date7 = new Date(2016, 0, 2); // 2 Jan 2016

date7.setDate(1); // задать первое число месяца
console.log(date7); // Jan 01 2016

date7.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца
console.log(date7); // 31 Dec 2015



// Преобразование к числу, разность дат

let date8 = new Date();
console.log(date8); // Wed Aug 14 2024 14:12:24
console.log(+date8); // 1723633967357

// Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах.
// Этот приём можно использовать для измерения времени:

let start = new Date(); // начинаем отсчёт времени

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i*i*i;
}

let end = new Date(); // заканчиваем отсчёт времени

console.log( `Цикл отработал за ${end - start} миллисекунд` );
// Цикл отработал за 2 миллисекунд



// Date.now()

// Если нужно просто измерить время, объект Date нам не нужен.

// Существует особый метод Date.now(), возвращающий текущую метку времени.

// Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.

// Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

// Вероятно, предыдущий пример лучше переписать так:

let started = Date.now(); // // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
    let doSomething = i * i * i;
  }
  
  let ended = Date.now(); // заканчиваем отсчёт времени
  
  console.log( `Цикл отработал за ${end - start} миллисекунд` ); // вычитаются числа, а не даты



  